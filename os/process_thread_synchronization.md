# 프로세스 동기화

현대 컴퓨터의 메모리에는 여러 프로세스가 존재하는데 이러한 프로세스들이 하나의 공유 메모리나 또 다른 프로세스에 접근할 때는 매우 신중해야 한다. 이처럼 한 프로세스가 다른 프로세스에게 영향을 받거나 주는 프로세스를 `Cooperation process`라고 한다. 반대는 `Independant process`이다.

현대에는 `Cooperation process`가 훨씬 많이 존재하고, 서로 영향을 미치기 때문에 데이터나 흐름에 대한 동기화가 매우 중요하며, 프로세스 사이에 동기화를 하는 것을 `프로세스 동기화 Process Synchronization`라고 한다. (현재는 대부분 스레드 기준으로 스위칭을 하므로 Thread Synchronization으로 많이 불린다.)

대표적인 예로 기차표 예매가 있다. 만약 한 좌석표를 동시에 여러 사람이 구매하려고 하면 어떤 일이 발생할까? 실제 환경은 동기화 문제가 해결된 시스템이므로 당연히 한사람만 구매할 수 있을 것이다. 하지만 만약 동기화에 문제가 발생한다면 한 기차표를 여러 사람이 예매하는 불상사가 발생할 것이다.

프로세스 동기화는 여러 프로세스가 공유하는 자원의 `일관성`을 유지하는 것이다. 가령 여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때, 이 프로세스들의 순서를 정하여 `Scheduling` 데이터의 일관성을 유지시켜 주어야 한다.

## Bank Account Problem 은행 계좌 문제

동기화 문제 중에서 대표적인 은행 계좌 문제를 살펴보자. 은행에는 하나의 계좌에 입금, 출금을 할 수 있다.

- 계좌: 공유하는 자원
- 입금, 출금: 프로세스

이를 자바로 구현한 코드는 아래와 같다.

```java
// Test.java
class Test {
	public static void main(String[] args) throws InterruptedException {
		BankAccount b = new BankAccount();
		Parent p = new Parent(b);
		Child c = new Child(b);
		p.start();   // start(): 쓰레드를 실행하는 메서드
		c.start();
		p.join();    // join(): 쓰레드가 끝나기를 기다리는 메서드
		c.join();
		System.out.println("balance = " + b.getBalance());
	}
}

// 계좌
class BankAccount {
	int balance;
	void deposit(int amount) {
		balance = balance + amount;
	}
	void withdraw(int amount) {
		balance = balance - amount;
	}
	int getBalance() {
		return balance;
	}
}

// 입금 프로세스
class Parent extends Thread {
	BankAccount b;
	Parent(BankAccount b) {
		this.b = b;
	}
	public void run() {   // run(): 쓰레드가 실제로 동작하는 부분(치환)
		for (int i = 0; i < 100; i++)
		  b.deposit(1000);
	}
}

// 출금 프로세스
class Child extends Thread {
	BankAccount b;
	Child(BankAccount b) {
		this.b = b;
	}
	public void run() {
		for (int i = 0; i < 100; i++)
		  b.withdraw(1000);
	}
}
```

위의 코드를 실행하면 대부분 아래와 같은 결과가 나온다.

`balance = 0`

위 결과는 정상이다. 100번 1000원을 입금하고 100번 1000원을 출금하면 잔액은 0원이다.

위 코드는 매우 간단한 코드이므로 2개의 스레드가 동작하고 있지만 동기화 문제가 발생할 확률은 매우 낮다. 조금 더 실제 상황과 비슷하도록 시간 지연을 시켜보자.

```java
// 계좌
class BankAccount {
	int balance;
	void deposit(int amount) {
		int temp = balance + amount;
		System.out.print("+");
		balance = temp;
	}
	void withdraw(int amount) {
		int temp = balance - amount;
		System.out.print("-");
		balance = temp;
	}
	int getBalance() {
		return balance;
	}
}
```

입금, 출금을 담당하는 `BankAccount`클래스의 입금과 출금 메서드에 약간의 시간 지연을 추가하였다. (println, 변수 대입 동작 추가) 그리고 입출금 횟수를 100에서 1000으로 늘려 주었다. 이 코드의 실행 결과는 다음과 같다.

```java
++++++++++++++++++++++++++++++++++----------------------------------------------
--------------------------------------------------------------------------++++++
+++----------------------------------------------+++++++++++++++++++++++++++++++
+----+++++++-+++++----+++-------------------------------------------------------
-+++++++-++++-+++++++++-------++++++++++++++++++++++++++++++++++++++++++++++++++
++++++---------------+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+-++++++++++++-------------------++++++++++++++++++++-++++++++++++++++++++++++++
++++++-+------------------------------------------------------------------------
-+++++++++++-+++++++----------------------------------------+-------+-----------
-+------+-----------------------------------------------------------------------
-+------------------------------------------------------------------------------
-+------------------------------------------------------------------------------
-------------------+-------+----------------------------------------------------
------------------------------+-------------------------------------------------
------------------------------------------------------+-------------------------
-+------------------------------------------------------------------------------
-++---------------------------------------++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

balance = 1000000
```

약간의 시간 지연을 준 것 만으로도 여러 쓰레드가 하나의 공유 자원을 사용하는 프로그램은 망가지게 된다. 이는 동기화 문제를 해결하지 못했기 때문에 생기는 문제이다.

이러한 문제는 `공통변수 common variable`에 대한 `동시 업데이트 concurrent update` 때문이다.

위 예제에서 공통 변수는 계좌의 잔액이다. 이에 접근하는 프로세스의 코드를 보면 다음과 같다.

```java
balance = balance + amount;   // 입금
balance = balance - amount;   // 출금
```

이는 자바 문법에서는 한 줄이라 문제 발생의 여지가 없어 보이지만, 로우 레벨인 어셈블리어로 내려가면 여러 줄로 구현된다. 두 번째 예제처럼 공통변수에 접근하는 부분에서 조금만 시간 지연을 발생시켜도 비정상적인 결과값이 나온 것을 알 수 있다.

이를 해결하는 방법은 공통변수에 접근하는 스레드는 하나만 존재하도록 관리해야 한다. 이러한 공통변수 구역을 `임계구역`이라고 한다.

## Critical section 임계구역 문제

임계구역은 여러 개의 스레드가 수행되는 시스템에서 각 스레드들이 공유하는 `데이터(변수, 테이블, 파일)을 변경하는 코드 영역`을 말한다. 이는 동기화에서 중요한 문제 중 하나이다.

임계구역을 해결하기 위해서는 3가지 조건이 만족되어야 한다.

- Mutual exclusion (상호배타): 오직 한 스레드만 접근 가능하다. 한 스레드가 임계구역에서 실행 중인 상태라면 다른 스레드는 접근이 불가하다.
- Progress (진행): 한 임계구역에 접근하는 스레드를 결정하는 것은 유한 시간 이내에 이루어져야 한다.
- Bounded waiting (유한대기): 임계구역으로 진입하기 위해 대기하는 모든 스레드는 유한시간 이내에 해당 임계구역에 진입할 수 있어야 한다.

### 프로세스/스레드 동기화

프로세스/스레드 동기화를 통해 이루고자 하는 목적은 다음과 같다.

- 원하는 결과값을 도출하도록 입계구역 문제를 해결한다.
- 프로세스의 실행 순서를 원하는대로 제어한다.
- Busy wait등과 같은 비효율성을 제거한다.

## Semaphore 세마포

세마포는 동기화를 위해 만들어진 소프트웨어로서, 대표적인 동기화 도구이다. 사전적 의미로는 역이나 군대에서 사용하는 수신호라는 뜻이다.

세마포에는 두가지 동작이 존재하는데, 초기에는 P, V로 불렸다. (네덜란드에서 만들어져서 네덜란드어의 약자이다) 현재 P는 test를 의미하며 `acquire`로 사용하고, V는 imcrement를 의미하며 `release`로 사용한다.

```Java
class Semaphore {
  int value;      // number of permits
  Semaphore(int value) {
    // ...
  }
  void acquire() {
    value--;
    if (value < 0) {
      // add this process/thread to list
      // block
    }
  }
  void release() {
    value++;
    if (value <= 0) {
      // remove a process P from list
      // wakeup P
    }
  }
}
```

위 코드에서 `acquire`는 value 값을 감소시키고 만약 value 값이 0보다 작으면 이미 해당 임계구역에 선행한 프로세스가 있다는 의미이므로 현재의 프로세스는 접근하지 못하도록 막아야 한다. 이를 Queue라는 기다리는 줄에 추가한 뒤 block을 걸어준다.

`release`는 value값을 증가시키고, 만약 value값이 0보다 작거나 같으면 임계구역에 진입하려고 대기하는 프로세스가 Queue에 남아있다는 의미이므로 그 중에서 하나를 꺼내어 임계구역을 수행할 수 있도록 해주어야 한다.

<img src="https://user-images.githubusercontent.com/34755287/53879679-5f302f00-4052-11e9-947a-5b048da2ea82.png" alt="img" style="zoom:67%;" />

세마포를 그림으로 나타내면 위와 같다. `acquire`에 의해 block 되는 프로세스는 세마포 내부에 있는 큐에 삽입된 후, 다른 프로세스가 임계구역을 나오면서 `release`를 호출해서 세마포 큐에 잇는 프로세스를 깨우고, 다시 ready 큐로 보낸다.

### 은행계좌 문제에 세마포 적용하기

```java
class BankAccount {
	int balance;

	Semaphore sem, semOrder;
	BankAccount() {
		sem = new Semaphore(1);
		semOrder = new Semaphore(0);   // Ordeing을 위한 세마포
	}

	void deposit(int amount) {
		try {
			sem.acquire();
		} catch (InterruptedException e) {}
		int temp = balance + amount;
		System.out.print("+");
		balance = temp;
		sem.release();
		semOrder.release();   // block된 출금 프로세스가 있다면 깨워준다.
	}
	void withdraw(int amount) {
		try {
			semOrder.acquire();   // 출금을 먼저하려고 하면 block한다.
			sem.acquire();
		} catch (InterruptedException e) {}
		int temp = balance - amount;
		System.out.print("-");
		balance = temp;
		sem.release();
	}
	int getBalance() {
		return balance;
	}
}
```

