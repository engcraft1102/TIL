# WebRTC란?

**WebRCT(Web Real-Time Communication)은 웹 애플리케이션과 사이트가 중간자 없이 브라우저 간에 오디오나 영상 미디어를 포착하고 마음대로 스트림 할 뿐 아니라, 임의의 데이터도 교환할 수 있도록 하는 기술입니다.**

한마디로 드라이버나 플러그인 설치 없이 웹 브라우저 간의 P2P 연결을 통해 데이터 교환을 가능하게 하는 기술입니다. 이 WebRTC의 등장과 발전은 개인화된 웹을 상징하는 웹 3.0과도 같은 길을 걷고 있습니다.

월드 와이드 웹 (World Wide Web)이 1990년대에 처음 등장했을 때, 웹은 단순히 하이퍼링크로 연결된 정적인(static) 문서 기반의 모델이었습니다. 그러다가 2000년대 중반에 이르러 XHR(XMLHttpRequest) 방식을 통해 페이지 전환 없이 동적으로 데이터를 받아올 수 있게 되면서, 웹은 동적인 앱을 제작할 수 있는 플랫폼이 되었습니다. 이때 등장한 웹 앱으로 Gmail, Facebook, Twitter 같은 것들이 있죠.

WebRTC는 기존의 웹 2.0에서 한층 더 나아가, 서버와 같은 중간자를 거치지 않고 브라우저끼리 P2P로 연결하는 기술입니다. 우리가 사용하는 화상통화, 실시간 스트리밍, 파일 공유, 스크린 공유 등이 WebRTC를 기반으로 하고 있습니다. p2p 연결은 중개 서버를 거치지 않기 때문에 빠른 속도가 보장되며, HTTPS가 강제되기 때문에 중간자 공격에 대한 보안이 보장됩니다. 그리고 실시간으로 상호작용 할 수 있다는 특성을 바탕으로 더욱 개인화되고 참여 유도적인 웹 어플리케이션을 제작할 기회가 되기도 합니다.

p2p 연결에서는 속도와 보안, 효율성을 고려해야겠지만, WebRTC가 범용적으로 사용되기 위해서는 **다양한 플랫폼과 브라우저에서 접속하는 사용자들에게 동일한 사용자 경험을 제공하는 일**이 첫 번째일 것입니다. 때문에 WebRTC에서 브라우저와 플랫폼 간 호환성은 가장 큰 숙제입니다.

# 브라우저 호환성

WebRTC는 구글이 주도한 오픈소스 프로젝트를 기반으로 하는 웹 표준이기 때문에, 특히 크롬에서 호환성이 높습니다. 파이어폭스, 오페라도 WebRTC 표준을 적극적으로 후원하고 있죠. 사파리도 WebKit 기반 브라우저이기 때문에 WebRTC가 지원되기는 하지만, 애플 특으로 호환성이 별로입니다.

즉, WebRTC는 아직까지 다양한 플랫폼에서 표준화가 완전히 구현되지는 않은 기술입니다. 정확히는 WebRTC 자체는 1.0버전의 표준이 있지만, 이 규격을 모두 준수하는 플랫폼들이 아직까지 많지 않습니다. 그러니까 브라우저와 운영체제 마다 호환성과 상호 운용성이 상이하다는 것입니다. 그래서 각 브라우저의 WebRTC API에는 `moz`, `webkit` 같은 [벤더 프리픽스(vendor prefix)](https://www.notion.so/Vendor-Prefix-a84f26eeb34140418527bb58808c8260)가 붙어있습니다.

이런 크로스 브라우징 이슈를 해결하기 위해서는 [adapter.js라이브러리](https://github.com/webrtcHacks/adapter)가 필수입니다. 이 라이브러리는 [shim 패턴](https://en.wikipedia.org/wiki/Shim_(computing)) 및 폴리필을 이용해 다양한 브라우저에서 발생할 수 있는 크로스 브라우징 이슈를 사전에 처리해줍니다. 또한, 벤더 프리픽스를 신경 쓸 필요 없이 동일한 API를 호출할 수 있게 만들어 주기 때문에, 코드 컨벤션 유지와 개발 생산성 향상에서도 큰 도움을 줍니다.

결론적으로 **WebRTC는 단일 브라우저 벤더에서 제공하는 API가 아니며, 브라우저와 운영체제별로 개발되는 속도와 지원되는 버전이 다르므로 호환성과 상호 운용성을 항상 체크**해야 합니다.

# P2P 절차

WebRTC는 p2p 방식의 커뮤니케이션이기 때문에 각각의 웹 브라우저는 다음과 같은 절차를 밟아야 합니다.

1. 각 브라우저가 p2p 커뮤니케이션에 동의
2. 서로의 주소를 공유
3. 보안 사항 및 방화벽 우회
4. 멀티미디어 데이터를 실시간으로 교환

여기서 우리는 2번과 3번 단계가 일반적인 웹 개발의 접근 방법으로는 해결하기 어렵다는 것을 알 수 있습니다. 왜냐하면 브라우저는 웹 서버가 아니기 때문에, 외부에서 접근할 수 있는 주소가 없기 때문이죠. 때문에 WebRTC가 P2P 기반이긴 하지만 통신설정 초기 단계에서는 중재자의 역할이 중요합니다.

# 방화벽과 NAT 트래버셜

일반적인 컴퓨터에는 공인 IP가 할당되어 있지 않습니다. 그 원인으로는 방화벽(Firewall), 여러 대의 컴퓨터가 하나의 공인 IP를 공유하는 [NAT(네트워크 주소 변환)](https://ko.wikipedia.org/wiki/네트워크_주소_변환), 유휴 상태의 IP를 일시적으로 임대받는 DHCP 때문입니다. 이 때문에 단순히 공인 IP만을 알아낸다고 해서 특정한 사용자를 가리킬 수는 없습니다. 공인 IP 뿐만 아니라 해당 네트워크에 연결된 사설 IP 주소까지 알아내야 특정한 사용자를 지정할 수 있게 되죠.

일반적으로는 라우터가 NAT 역할을 합니다. 외부에서 접근하는 공인 IP와 포트 번호를 확인하여 현재 네트워크 내의 사설 IP들을 적절히 매칭시켜주죠. 그러니까 어떤 브라우저 두 개가 서로 직접 통신을 하려면, 각자 현재 연결된 라우터의 공인 IP 주소와 포트를 먼저 알아내야 합니다.

하지만 어떤 라우터들은 특정 주소나 포트와의 연결을 차단하는 방화벽 설정이 되어 있을 수도 있습니다. 이처럼 **라우터를 통과해서 연결할 방법을 찾는 과정**을 [NAT 트래버셜](https://en.wikipedia.org/wiki/NAT_traversal) 이라고 합니다.

# STUN, TURN

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c2c67f3d-eb95-441e-8e04-97bd3a94246f/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c2c67f3d-eb95-441e-8e04-97bd3a94246f/Untitled.png)

이 NAT 트래퍼셜 작업은 STUN 서버에 의해 이루어집니다. STUN 방식은 **단말이 자신의 공인 IP 주소와 포트를 확인하는 과정에 대한 프로토콜**입니다.

즉, STUN 서버는 인터넷의 복잡한 주소들 속에서 유일하게 자기 자신을 식별할 수 있는 정보를 반환해줍니다. 즉, WebRTC 연결을 시작하기 전에 STUN 서버를 향해 요청을 보내면, STUN 서버는 NAT 뒤에 있는 피어(Peer)들이 서로 연결할 수 있도록 공인 IP와 포트를 찾아줍니다.

쉽게 말해서 다른 사람이 우리 집에 쉽게 찾아올 수 있도록 사전에 우리 집 주소를 조회해서 알아내는 것과 같습니다. 만약 두 개의 장치가 성공적으로 STUN 서버에서 자기 자신의 주소를 알아냈을 경우에는 P2P 연결을 시도할 두 개의 고유한 주소가 생긴 셈입니다.

하지만 STUN 서버를 이용하더라도 항상 자신의 정보를 알아낼 수 있는 것은 아닙니다. 라우터 별로 방화벽 정책이 다를 수도 있고, 이전에 연결된 적이 있는 네트워크만 연결되도록 제한을 걸기도 합니다(Symmetric NAT). 이 때문에 STUN 서버를 통해 자기 자신의 주소를 찾아내지 못했을 경우, TURN 서버를 대안으로 이용하게 됩니다.

TURN 방식은 네트워크 미디어를 중개하는 서버를 이용하는 것입니다. TURN 방식은 중간에 서버를 한 번 거치기 때문에, 엄밀히 이야기하자면 P2P 통신이 아니게 되며 그 구조상 지연이 필연적으로 발생하게 됩니다. 하지만 보안 정책이 엄격한 개인 NAT 내부에 위치한 브라우저와 P2P 통신을 할 수 있는 유일한 방법이기 때문에 TURN 방식은 최후의 수단으로 선택되어야 합니다.

# ICE와 Candidate

지금까지의 **STUN, TURN 서버를 이용해서 획득했던 IP 주소와 Protocol, Port의 조합으로 구성된 연결 가능한 네트워크 주소들을 후보(Candidate)라고 부릅니다.** 그리고 이 과정을 후보 찾기라고 부릅니다.

이렇게 후보들을 수집하면 일반적으로 3개의 주소를 얻게 됩니다.

- 자신의 사설 IP와 포트
- 자신의 공인 IP와 포트 (STUN, TURN 서버로부터 획득)
- TURN 서버의 IP와 포트 넘버 (TURN 서버로부터 획득)

한편, 이 모든 과정은 ICE(Interactive Connectivity Establishment)라는 프레임워크 위에서 이루어집니다. ICE는 두 개의 단말이 P2P 연결을 가능하게 하도록 최적의 경로를 찾아주는 프레임워크입니다.

지금까지의 내용을 요약하자면 ICE 프레임워크가 STUN 또는 TURN 서버를 이용해 상대방과 연결 가능한 후보들을 갖고 있다는 것입니다. 그러니까 두 브라우저가 P2P 통신을 위해 통신할 수 있는 주소만큼은 확실하게 알아낸 것입니다. 따라서 마지막으로 남은 것은 이제 미디어와 관련된 정보를 교환하는 것입니다.

# SDP

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6f7c93a4-ad2c-4400-b47a-04a4249d7b8f/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6f7c93a4-ad2c-4400-b47a-04a4249d7b8f/Untitled.png)

직렬화된 SDP 데이터. JS에서 읽기 쉽게 보려면 별도의 라이브러리를 쓰는 것이 좋다.

SDP(Session Description Protocol)는 WebRTC에서 스트리밍 미디어의 해상도나 형식, 코덱 등의 멀티미디어 컨텐츠의 초기 인수를 설명하기 위해 채택한 프로토콜입니다. 화상 통화 어플리케이션을 예시로 들어보자면 웹캠 비디오의 해상도를 보낼 수 있고, 오디오 전송 또는 수신 여부를 보낼 수도 있겠죠.

이처럼 미디어오 ㅏ관련된 초기 세팅 정보를 기술하는 SDP는 [발행 구독 모델(Pub/Sub)](https://ko.wikipedia.org/wiki/발행-구독_모델)과 유사한 제안 응답 모델(Offer/Answer)을 갖고 있습니다. 그러니까 어떤 피어가 이러한 미디어 스트림을 교환할 것이라고 제안을 하면, 상대방으로부터 응답이 오기를 기다린다는 의미입니다.

그렇게 응답을 받게 되면 각자의 피어가 수집한 ICE 후보 중에서 최적의 경로를 결정하고 협상하는 프로세스가 발생합니다. 수집한 ICE 후보들로 패킷을 보내 가장 지연 시간이 적고 안정적인 경로를 찾는 것이죠. 이렇게 최적의 ICE 후보가 선택되면, 기본적으로 필요한 모든 메타 데이터와 IP 주소 및 포트, 미디어 정보의 피어 간 합의가 완료됩니다.

이 과정을 통해 피어 간의 P2P 연결이 완전히 설정되고 활성화됩니다. 그 후 각 피어에 의해 로컬 데이터 스트림의 엔드포인트가 생성되며, 이 데이터는 양방향 통신 기술을 사용하여 최종족으로 전송됩니다.

이 과정에서 NAT의 보안 이슈 등으로 최선의 ICE 후보를 찾지 못할 수도 있기 때문에 이 때에는 폴백으로 세팅한 TURN 서버를 P2P 대용으로 설정합니다.

통신에 TURN 폴백을 사용할 때 각 피어는 굳이 귀찮게 P2P로 데이터를 연결하고 전송하는 방법을 알 필요가 없습니다. 대신 통신 세션 중에 실시간 멀티미디어 데이터를 중개하는 공용 TURN 서버를 알고 있어야 합니다.

# Trickle ICE

ICE 후보 교환 작업을 병렬 프로세스로 수행할 수 있게 만드는 것입니다.

웬만하면 활성화하는 것이 좋겠습니다.

# 시그널링

위에서 얘기한 모든 과정을 일컬어 시그널링이라고 부릅니다. 즉 RTCPeerConnection 통신에 사용할 프로토콜, 채널, 미디어 코덱 및 형식, 데이터 전송 방법, 라우팅 정보와 NAT 통과 방법을 포함한 통신 규격을 교환하기 위한 두 장치의 제어 정보를 교환하는 과정을 의미합니다.

## 참조

------

- https://wormwlrm.github.io/2021/01/24/Introducing-WebRTC.html
- https://gh402.tistory.com/38?category=935378
- [PeerJS로 WebRTC 사용해보기](https://velog.io/@mgm-dev/PeerJS로-WebRTC-쉽게-사용해보기)
- https://github.com/sockjs/sockjs-client
- https://github.com/jmesnil/stomp-websocket
- http://jmesnil.net/stomp-websocket/doc/

## 하위 문서

------

[Vendor Prefix](https://www.notion.so/Vendor-Prefix-a84f26eeb34140418527bb58808c8260)

[Polyfill](https://www.notion.so/Polyfill-d06bb5934def4eb9a595201b76120f7b)

[STUN, TURN](https://www.notion.so/STUN-TURN-1164689c89cc4b439312fe719ad274d1)